#!/usr/bin/env python
# A script to ensure that, after we build, we regenerate the CompileDB so that
# vs code can complete things properly. Also tries to be smart and do a full
# build if necessary, and do just build binaries when possible to save time.

import json
import os
import subprocess
import sys


def run_mach(args, cwd, timed):
    if sys.platform == 'win32':
        # win32 ignores timed... for now
        mach_dir = '/' + cwd.replace(':', '').replace('\\', '/').lower()
        mach_wrapper = '/'.join([mach_dir, '.vscode', 'mach_wrapper_win'])
        subprocess.call(['c:\\mozilla-build\\start-shell.bat', mach_wrapper, mach_dir] + args, cwd=cwd)
        try:
            mach_result = json.load(file(os.path.join(cwd, '.vscode', 'mach-result.json')))
            return mach_result['code']
        except Exception as e:
            sys.stderr.write('Error getting mach result: %s\n' % (e,))
            return 1

    if timed:
        mach = ['time', './mach']
    else:
        mach = ['./mach']
    return subprocess.call(mach + args, cwd=cwd)


is_git = False
is_hg = False


def different_branch(ref, head, cwd):
    if not ref:
        # short-circuit for first-time run
        return True

    if is_git:
        return different_branch_git(ref, head, cwd)
    elif is_hg:
        return different_branch_hg(ref, head, cwd)
    return different_branch_wat(ref, head, cwd)


def different_branch_git(ref, head, cwd):
    if subprocess.call(['git', 'merge-base', '--is-ancestor', ref, head], cwd=cwd) == 0:
        # ref is an ancestor of head, therefore we are effectively on the same
        # branch (for the purposes of building - headers won't have changed)
        return False
    return True


def different_branch_hg(ref, head, cwd):
    try:
        output = subprocess.check_output(['hg', 'log', '-r', '%s::%s' % (ref, head)], cwd=cwd).strip()
    except subprocess.CalledProcessError:
        # Something failed - perhaps one of the refs we asked about is obsolete. Assume
        # a different branch, for safety's sake.
        return True
    if output:
        # ref is an ancestor of head, therefore we are effectively on the same
        # branch (for the purposes of building - headers won't have changed)
        return False
    return True


def different_branch_wat(ref, head, cwd):
    # Just for schitzengiggel, assume things have changed
    return True

if sys.platform != 'win32':
    workspace_dir = sys.argv[1]
    mach = ['./mach']
else: # sys.platform == 'win32'
    mach = ['c:\\mozilla-build\\start-shell.bat', 'mach']
    workspace_dir = os.environ.get('NWGH_WORKSPACE_FOLDER', None)
    if not workspace_dir:
        sys.stderr.write('Could not find workspace folder\n')
        sys.exit(1)

if os.path.exists(os.path.join(workspace_dir, '.git')):
    is_git = True
    is_hg = False
elif os.path.exists(os.path.join(workspace_dir, '.hg')):
    is_git = False
    is_hg = True
else:
    sys.stderr.write('Not a git or hg checkout\n')
    sys.exit(1)

forced_command = None
if len(sys.argv) > 2:
    if sys.argv[2] == 'force':
        forced_command = 'build'
    elif sys.argv[2] == 'clobber':
        forced_command = 'clobber'
    elif sys.argv[2] == 'binaries':
        forced_command = 'binaries'

p = subprocess.Popen(mach + ['environment', '--format', 'json'], cwd=workspace_dir, stdout=subprocess.PIPE)
p.wait()
environment = json.load(p.stdout)
object_dir = environment['topobjdir']

ccache_path = None
for arg in environment['mozconfig']['configure_args']:
    if arg.startswith('--with-ccache='):
        ccache_path = arg.split('=')[1]

vscode_dir = os.path.join(workspace_dir, '.vscode')
build_config_file = os.path.join(vscode_dir, 'last-build-config.json')
last_build_config = {'result': 1, 'command': 'build', 'head': ''}
if os.path.exists(build_config_file):
    with file(build_config_file) as f:
        last_build_config.update(json.load(f))

last_head = current_head = last_build_config['head']
if is_git:
    current_head = subprocess.check_output(['git', 'rev-parse', 'HEAD'], cwd=workspace_dir).strip()
elif is_hg:
    current_head = subprocess.check_output(['hg', 'id', '-i', '-r', '.'], cwd=workspace_dir).strip()
else:
    sys.stderr.write('WTF?!')
    sys.exit(1)

if forced_command:
    command = forced_command
    if forced_command == 'clobber':
        run_mach(['clobber'], workspace_dir)
        command = 'build'
elif different_branch(last_head, current_head, workspace_dir):
    # We are on a branch that is not a descendent of the last branch we worked
    # on, so force a full rebuild to ensure new headers, etc are picked up.
    command = 'build'
elif last_build_config['result'] != 0:
    # This failed last time, so just try the same one again
    command = last_build_config['command']
else:
    # We can try just building the binaries
    command = 'binaries'

last_build_config['command'] = command
last_build_config['head'] = current_head

args = ['--log-no-times', 'build']
if command == 'binaries':
    args.append('binaries')

sys.stdout.write('> Running mach %s\n' % (' '.join(args),))
result = run_mach(args, workspace_dir, True)
last_build_config['result'] = result
if command == 'build' and result == 0:
    # Now is the time to update the compile_commands.json used by vs code
    sys.stdout.write('> Generating CompileDB Backend\n')
    run_mach(['--log-no-times', 'build-backend', '-b', 'CompileDB'], workspace_dir, False)
    if sys.platform == 'win32':
        # Also generate Visual Studio backend on windows
        sys.stdout.write('> Generating Visual Studio Backend\n')
        run_mach(['--log-no-times', 'build-backend', '-b', 'VisualStudio'], workspace_dir, False)

    # Since mach puts the ccache command in our compiledb, we need to strip that
    # information out so as to not confuse vs code
    if ccache_path and sys.platform != 'win32':
        sed_command = 's/%s //g' % (ccache_path.replace('/', '\\/'),)
        compile_commands = os.path.join(object_dir, 'compile_commands.json')
        new_compile_commands = '%s.new' % (compile_commands,)
        with file(compile_commands) as old:
            with file(new_compile_commands, 'w') as new:
                subprocess.call(['sed', '-e', sed_command], stdin=old, stdout=new)
        os.rename(new_compile_commands, compile_commands)

# Update our on-disk status
with file(build_config_file, 'w') as f:
    json.dump(last_build_config, f)
